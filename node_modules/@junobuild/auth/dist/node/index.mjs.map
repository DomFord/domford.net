{
  "version": 3,
  "sources": ["../../src/authenticate.ts", "../../src/_context.ts", "../../src/_constants.ts", "../../src/errors.ts", "../../src/utils/auth.utils.ts", "../../src/utils/url.utils.ts", "../../src/utils/session-storage.utils.ts", "../../src/utils/state.utils.ts", "../../src/_session.ts", "../../src/api/_actor.api.ts", "../../src/api/auth.api.ts", "../../src/utils/session.utils.ts", "../../src/_openid.ts", "../../src/request.ts", "../../src/utils/openid.utils.ts"],
  "sourcesContent": ["import {isEmptyString} from '@dfinity/utils';\nimport {loadContext} from './_context';\nimport {authenticateSession} from './_session';\nimport {\n  AuthenticationInvalidStateError,\n  AuthenticationUndefinedJwtError,\n  AuthenticationUrlHashError\n} from './errors';\nimport type {\n  AuthenticatedSession,\n  AuthenticationParams,\n  AuthParameters\n} from './types/authenticate';\nimport type {OpenIdAuthContext} from './types/context';\n\nexport const authenticate = async <T extends AuthParameters>(\n  params: AuthenticationParams<T>\n): Promise<AuthenticatedSession<T>> => {\n  const context = loadContext();\n\n  if ('credentials' in params) {\n    const {\n      credentials: {jwt},\n      auth\n    } = params;\n\n    return await authenticateSession({\n      jwt,\n      context,\n      auth\n    });\n  }\n\n  return await authenticateWithRedirect<T>({...params, context});\n};\n\nconst authenticateWithRedirect = async <T extends AuthParameters>({\n  auth,\n  context\n}: {\n  auth: AuthParameters;\n  context: OpenIdAuthContext;\n}): Promise<AuthenticatedSession<T>> => {\n  const {\n    location: {hash}\n  } = window;\n\n  if (isEmptyString(hash) || !hash.startsWith('#')) {\n    throw new AuthenticationUrlHashError('No hash found in the current location URL');\n  }\n\n  const params = new URLSearchParams(hash.slice(1));\n  const state = params.get('state');\n  const idToken = params.get('id_token');\n\n  const {state: savedState} = context;\n\n  if (isEmptyString(savedState) || state !== savedState) {\n    throw new AuthenticationInvalidStateError('The provided state is invalid', {cause: state});\n  }\n\n  // id_token === jwt\n  if (isEmptyString(idToken)) {\n    throw new AuthenticationUndefinedJwtError();\n  }\n\n  return await authenticateSession({\n    jwt: idToken,\n    auth,\n    context\n  });\n};\n", "import {isNullish} from '@dfinity/utils';\nimport {Ed25519KeyIdentity} from '@icp-sdk/core/identity';\nimport {CONTEXT_KEY} from './_constants';\nimport {ContextUndefinedError} from './errors';\nimport type {OpenIdAuthContext} from './types/context';\nimport type {Nonce} from './types/nonce';\nimport {generateNonce} from './utils/auth.utils';\nimport {parseContext, stringifyContext} from './utils/session-storage.utils';\nimport {generateRandomState} from './utils/state.utils';\n\nexport const initContext = async (): Promise<{nonce: Nonce} & Pick<OpenIdAuthContext, 'state'>> => {\n  const caller = Ed25519KeyIdentity.generate();\n  const {nonce, salt} = await generateNonce({caller});\n  const state = generateRandomState();\n\n  const storedData = stringifyContext({\n    caller,\n    salt,\n    state\n  });\n\n  sessionStorage.setItem(CONTEXT_KEY, storedData);\n\n  return {\n    nonce,\n    state\n  };\n};\n\nexport const loadContext = (): OpenIdAuthContext => {\n  const storedContext = sessionStorage.getItem(CONTEXT_KEY);\n\n  if (isNullish(storedContext)) {\n    throw new ContextUndefinedError();\n  }\n\n  return parseContext(storedContext);\n};\n", "import type {OpenIdProvider} from './types/provider';\n\nexport const CONTEXT_KEY = 'juno:auth:openid';\n\n// Create client_id: https://developers.google.com/identity/openid-connect/openid-connect#authenticationuriparameters\nexport const GOOGLE_PROVIDER: Omit<OpenIdProvider, 'clientId' | 'redirectUrl'> = {\n  authUrl: 'https://accounts.google.com/o/oauth2/v2/auth',\n  authScopes: ['openid', 'profile', 'email'],\n  configUrl: 'https://accounts.google.com/gsi/fedcm.json'\n};\n", "export class InvalidUrlError extends Error {}\nexport class ContextUndefinedError extends Error {}\n\nexport class FedCMIdentityCredentialUndefinedError extends Error {}\nexport class FedCMIdentityCredentialInvalidError extends Error {}\n\nexport class AuthenticationError extends Error {}\nexport class AuthenticationUrlHashError extends Error {}\nexport class AuthenticationInvalidStateError extends Error {}\nexport class AuthenticationUndefinedJwtError extends Error {}\n\nexport class GetDelegationError extends Error {}\nexport class GetDelegationRetryError extends Error {}\n", "import {arrayBufferToUint8Array} from '@dfinity/utils';\nimport type {Ed25519KeyIdentity} from '@icp-sdk/core/identity';\nimport type {Nonce, Salt} from '../types/nonce';\nimport {toBase64URL} from './url.utils';\n\nconst generateSalt = (): Salt => window.crypto.getRandomValues(new Uint8Array(32));\n\nconst buildNonce = async ({salt, caller}: {salt: Salt; caller: Ed25519KeyIdentity}) => {\n  const principal = caller.getPrincipal().toUint8Array();\n\n  const bytes = new Uint8Array(salt.length + principal.byteLength);\n  bytes.set(salt);\n  bytes.set(principal, salt.length);\n\n  const hash = await window.crypto.subtle.digest('SHA-256', bytes);\n\n  return toBase64URL(arrayBufferToUint8Array(hash));\n};\n\nexport const generateNonce = async ({\n  caller\n}: {\n  caller: Ed25519KeyIdentity;\n}): Promise<{nonce: Nonce; salt: Salt}> => {\n  const salt = generateSalt();\n  const nonce = await buildNonce({salt, caller});\n\n  return {nonce, salt};\n};\n", "import {uint8ArrayToBase64} from '@dfinity/utils';\n\n// In the future: uint8Array.toBase64({ alphabet: \"base64url\" })\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array/toBase64\nexport const toBase64URL = (uint8Array: Uint8Array): string =>\n  uint8ArrayToBase64(uint8Array).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n", "import {base64ToUint8Array, uint8ArrayToBase64} from '@dfinity/utils';\nimport {Ed25519KeyIdentity, type JsonnableEd25519KeyIdentity} from '@icp-sdk/core/identity';\nimport type {OpenIdAuthContext} from '../types/context';\n\nconst JSON_KEY_CALLER = '__caller__';\nconst JSON_KEY_SALT = '__salt__';\nconst JSON_KEY_STATE = '__state__';\n\ninterface StoredContext {\n  [JSON_KEY_CALLER]: JsonnableEd25519KeyIdentity;\n  [JSON_KEY_SALT]: string;\n  [JSON_KEY_STATE]: string;\n}\n\nexport const stringifyContext = ({caller, state, salt}: OpenIdAuthContext): string => {\n  const data: StoredContext = {\n    [JSON_KEY_CALLER]: caller.toJSON(),\n    [JSON_KEY_SALT]: uint8ArrayToBase64(salt),\n    [JSON_KEY_STATE]: state\n  };\n\n  return JSON.stringify(data);\n};\n\nexport const parseContext = (jsonData: string): OpenIdAuthContext => {\n  const {\n    [JSON_KEY_CALLER]: jsonCaller,\n    [JSON_KEY_SALT]: jsonSalt,\n    [JSON_KEY_STATE]: state\n  }: StoredContext = JSON.parse(jsonData);\n\n  return {\n    caller: Ed25519KeyIdentity.fromParsedJson(jsonCaller),\n    salt: base64ToUint8Array(jsonSalt),\n    state\n  };\n};\n", "import {toBase64URL} from './url.utils';\n\nexport const generateRandomState = (): string =>\n  toBase64URL(window.crypto.getRandomValues(new Uint8Array(12)));\n", "import {fromNullable} from '@dfinity/utils';\nimport type {Signature} from '@icp-sdk/core/agent';\nimport {Delegation, ECDSAKeyIdentity} from '@icp-sdk/core/identity';\nimport {authenticate as authenticateApi, getDelegation as getDelegationApi} from './api/auth.api';\nimport {AuthenticationError, GetDelegationError, GetDelegationRetryError} from './errors';\nimport type {AuthenticationData, GetDelegationArgs, SignedDelegation} from './types/actor';\nimport type {AuthenticatedSession, AuthParameters} from './types/authenticate';\nimport type {OpenIdAuthContext} from './types/context';\nimport type {Delegations} from './types/session';\nimport {generateIdentity} from './utils/session.utils';\n\ninterface AuthContext {\n  context: Omit<OpenIdAuthContext, 'state'>;\n  auth: AuthParameters;\n}\ntype AuthenticationArgs = {jwt: string} & AuthContext;\n\nexport const authenticateSession = async <T extends AuthParameters>({\n  jwt,\n  context,\n  auth\n}: AuthenticationArgs): Promise<AuthenticatedSession<T>> => {\n  const sessionKey = await ECDSAKeyIdentity.generate({extractable: false});\n\n  const publicKey = new Uint8Array(sessionKey.getPublicKey().toDer());\n\n  const {delegations, data} = await authenticate<T>({\n    jwt,\n    publicKey,\n    context,\n    auth\n  });\n\n  const identity = generateIdentity({\n    sessionKey,\n    delegations\n  });\n\n  return {identity, data};\n};\n\nconst authenticate = async <T extends AuthParameters>({\n  jwt,\n  publicKey,\n  context: {caller, salt},\n  auth\n}: {\n  publicKey: Uint8Array;\n} & AuthenticationArgs): Promise<{delegations: Delegations; data: AuthenticationData<T>}> => {\n  const result = await authenticateApi({\n    args: {\n      OpenId: {\n        jwt,\n        session_key: publicKey,\n        salt\n      }\n    },\n    actorParams: {\n      auth,\n      identity: caller\n    }\n  });\n\n  if ('Err' in result) {\n    throw new AuthenticationError('Authentication failed', {cause: result});\n  }\n\n  const {\n    delegation: {user_key: userKey, expiration},\n    ...rest\n  } = result.Ok;\n\n  const signedDelegation = await retryGetDelegation({\n    jwt,\n    context: {caller, salt},\n    auth,\n    publicKey,\n    expiration\n  });\n\n  const {delegation, signature} = signedDelegation;\n  const {pubkey, expiration: signedExpiration, targets} = delegation;\n\n  const delegations: Delegations = [\n    userKey,\n    [\n      {\n        delegation: new Delegation(\n          Uint8Array.from(pubkey),\n          signedExpiration,\n          fromNullable(targets)\n        ),\n        signature: Uint8Array.from(signature) as unknown as Signature\n      }\n    ]\n  ];\n\n  return {delegations, data: rest as AuthenticationData<T>};\n};\n\nconst retryGetDelegation = async ({\n  jwt,\n  publicKey,\n  context: {salt, caller},\n  auth,\n  expiration,\n  maxRetries = 5\n}: {\n  publicKey: Uint8Array;\n  expiration: bigint;\n  maxRetries?: number;\n} & AuthenticationArgs): Promise<SignedDelegation> => {\n  for (let i = 0; i < maxRetries; i++) {\n    // Linear backoff\n    await new Promise((resolve) => {\n      setInterval(resolve, 1000 * i);\n    });\n\n    const args: GetDelegationArgs = {\n      OpenId: {\n        jwt,\n        session_key: publicKey,\n        salt,\n        expiration\n      }\n    };\n\n    const result = await getDelegationApi({\n      args,\n      actorParams: {\n        auth,\n        identity: caller\n      }\n    });\n\n    if ('Err' in result) {\n      const {Err} = result;\n\n      if ('NoSuchDelegation' in Err) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if ('GetCachedJwks' in Err) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      throw new GetDelegationError('Getting delegation failed', {cause: result});\n    }\n\n    return result.Ok;\n  }\n\n  throw new GetDelegationRetryError();\n};\n", "import {\n  type ConsoleActor,\n  type SatelliteActor,\n  getConsoleActor,\n  getSatelliteActor\n} from '@junobuild/ic-client/actor';\nimport type {ActorParameters} from '../types/actor';\n\nexport const getAuthActor = ({\n  auth,\n  identity\n}: ActorParameters): Promise<ConsoleActor | SatelliteActor> =>\n  'satellite' in auth\n    ? getSatelliteActor({...auth.satellite, identity})\n    : getConsoleActor({...auth.console, identity});\n", "import type {\n  ActorParameters,\n  AuthenticationArgs,\n  AuthenticationResult,\n  GetDelegationArgs,\n  GetDelegationResult\n} from '../types/actor';\nimport {getAuthActor} from './_actor.api';\n\nexport const authenticate = async ({\n  actorParams,\n  args\n}: {\n  args: AuthenticationArgs;\n  actorParams: ActorParameters;\n}): Promise<AuthenticationResult> => {\n  const {authenticate} = await getAuthActor(actorParams);\n  return await authenticate(args);\n};\n\nexport const getDelegation = async ({\n  actorParams,\n  args\n}: {\n  args: GetDelegationArgs;\n  actorParams: ActorParameters;\n}): Promise<GetDelegationResult> => {\n  const {get_delegation} = await getAuthActor(actorParams);\n  return await get_delegation(args);\n};\n", "import {DelegationChain, DelegationIdentity, type ECDSAKeyIdentity} from '@icp-sdk/core/identity';\nimport type {AuthenticatedIdentity} from '../types/authenticate';\nimport type {Delegations} from '../types/session';\n\nexport const generateIdentity = ({\n  delegations,\n  sessionKey\n}: {\n  delegations: Delegations;\n  sessionKey: ECDSAKeyIdentity;\n}): AuthenticatedIdentity => {\n  const [userKey, signedDelegations] = delegations;\n\n  const delegationChain = DelegationChain.fromDelegations(\n    signedDelegations,\n    Uint8Array.from(userKey)\n  );\n\n  const identity = DelegationIdentity.fromDelegation(sessionKey, delegationChain);\n\n  return {identity, delegationChain, sessionKey};\n};\n", "import {isNullish, notEmptyString} from '@dfinity/utils';\nimport {\n  FedCMIdentityCredentialInvalidError,\n  FedCMIdentityCredentialUndefinedError,\n  InvalidUrlError\n} from './errors';\nimport type {RequestJwtWithCredentials, RequestJwtWithRedirect} from './types/openid';\n\n/**\n * Initiates an OpenID Connect authorization request by redirecting the browser.\n *\n *  References:\n *  - OAuth 2.0 (Google): https://developers.google.com/identity/protocols/oauth2/javascript-implicit-flow\n *  - OpenID Connect: https://developers.google.com/identity/openid-connect/openid-connect\n */\nexport const requestJwtWithRedirect = ({\n  authUrl,\n  clientId,\n  nonce,\n  loginHint,\n  authScopes,\n  state,\n  redirectUrl\n}: RequestJwtWithRedirect) => {\n  const parseAuthUrl = (): URL => {\n    try {\n      // Use the URL constructor, for backwards compatibility with older Android/WebView.\n      return new URL(authUrl);\n    } catch (_error: unknown) {\n      throw new InvalidUrlError('Cannot parse authURL', {cause: authUrl});\n    }\n  };\n\n  const requestUrl = parseAuthUrl();\n\n  requestUrl.searchParams.set('client_id', clientId);\n\n  const {\n    location: {origin: currentUrl}\n  } = window;\n\n  requestUrl.searchParams.set('redirect_uri', redirectUrl ?? currentUrl);\n\n  // We do not request \"token\" because we use the ID token (JWT).\n  // \"code\" is required according to II's codebase as Apple ID throws an error otherwise.\n  requestUrl.searchParams.set('response_type', 'code id_token');\n\n  requestUrl.searchParams.set('scope', authScopes.join(' '));\n\n  // Used for security reasons. When the provider redirects to the application,\n  // the state will be compared with the session storage value.\n  requestUrl.searchParams.set('state', state);\n\n  // Used to validate the JSON Web Token (JWT) in the backend \u2014 i.e. we pass the nonce\n  // to the provider and make the request to the backend with its salt.\n  requestUrl.searchParams.set('nonce', nonce);\n\n  if (notEmptyString(loginHint)) {\n    requestUrl.searchParams.set('login_hint', loginHint);\n  } else {\n    requestUrl.searchParams.set('prompt', 'select_account');\n  }\n\n  window.location.href = requestUrl.toString();\n};\n\n/**\n * References:\n * - identity spec: https://www.w3.org/TR/fedcm/#browser-api-credential-request-options\n * - https://privacysandbox.google.com/cookies/fedcm/implement/identity-provider\n * - https://privacysandbox.google.com/cookies/fedcm/why\n */\nexport const requestWithCredentials = async ({\n  configUrl: configURL,\n  clientId,\n  nonce,\n  loginHint,\n  domainHint\n}: RequestJwtWithCredentials): Promise<{jwt: string}> => {\n  const identityCredential = await navigator.credentials.get({\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    identity: {\n      context: 'use',\n      providers: [\n        {\n          configURL,\n          clientId,\n          nonce,\n          loginHint,\n          domainHint\n        }\n      ],\n      mode: 'active'\n    },\n    // https://privacysandbox.google.com/cookies/fedcm/implement/relying-party#auto-reauthn\n    mediation: 'required'\n  });\n\n  if (isNullish(identityCredential)) {\n    throw new FedCMIdentityCredentialUndefinedError();\n  }\n\n  const {type} = identityCredential;\n\n  if (\n    type !== 'identity' ||\n    !('token' in identityCredential) ||\n    typeof identityCredential.token !== 'string'\n  ) {\n    // This should be unreachable in FedCM spec-compliant browsers.\n    throw new FedCMIdentityCredentialInvalidError('Invalid credential received from FedCM API', {\n      cause: identityCredential\n    });\n  }\n\n  const {token: jwt} = identityCredential;\n  return {jwt};\n};\n", "import {GOOGLE_PROVIDER} from './_constants';\nimport {initContext} from './_context';\nimport {requestJwtWithRedirect, requestWithCredentials} from './_openid';\nimport type {\n  RequestJwtCredentialsParams,\n  RequestJwtCredentialsResult,\n  RequestJwtParams,\n  RequestJwtRedirectParams\n} from './types/request';\n\nexport function requestJwt(args: {\n  google: RequestJwtCredentialsParams;\n}): Promise<RequestJwtCredentialsResult>;\n\nexport function requestJwt(args: {google: RequestJwtRedirectParams}): Promise<void>;\n\nexport async function requestJwt({\n  google\n}: {\n  google: RequestJwtParams;\n}): Promise<RequestJwtCredentialsResult | void> {\n  const context = await initContext();\n\n  if ('credentials' in google) {\n    const {credentials} = google;\n    const {configUrl} = GOOGLE_PROVIDER;\n\n    return await requestWithCredentials({\n      ...credentials,\n      ...context,\n      configUrl\n    });\n  }\n\n  const {redirect} = google;\n  const {authUrl, authScopes} = GOOGLE_PROVIDER;\n\n  requestJwtWithRedirect({\n    ...redirect,\n    ...context,\n    authUrl,\n    authScopes\n  });\n}\n", "/**\n * Detects whether the browser supports FedCM (Federated Credential Management).\n *\n * @returns {boolean} `true` if FedCM is supported, otherwise `false`.\n *\n * References:\n *  - MDN IdentityCredential: https://developer.mozilla.org/en-US/docs/Web/API/IdentityCredential\n */\nexport const isFedCMSupported = (): boolean => {\n  const {userAgent} = navigator;\n\n  // Samsung browser implements \"IdentityCredential\" but does not support \"configURL\"\n  // https://developer.mozilla.org/en-US/docs/Web/API/IdentityCredential\n  const isSamsungBrowser = /SamsungBrowser/i.test(userAgent);\n  if (isSamsungBrowser) {\n    return false;\n  }\n\n  return 'IdentityCredential' in window;\n};\n"],
  "mappings": "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",
  "names": ["isEmptyString", "isNullish", "Ed25519KeyIdentity", "CONTEXT_KEY", "GOOGLE_PROVIDER", "InvalidUrlError", "ContextUndefinedError", "FedCMIdentityCredentialUndefinedError", "FedCMIdentityCredentialInvalidError", "AuthenticationError", "AuthenticationUrlHashError", "AuthenticationInvalidStateError", "AuthenticationUndefinedJwtError", "GetDelegationError", "GetDelegationRetryError", "arrayBufferToUint8Array", "uint8ArrayToBase64", "toBase64URL", "uint8Array", "generateSalt", "buildNonce", "salt", "caller", "principal", "bytes", "hash", "toBase64URL", "arrayBufferToUint8Array", "generateNonce", "base64ToUint8Array", "uint8ArrayToBase64", "Ed25519KeyIdentity", "JSON_KEY_CALLER", "JSON_KEY_SALT", "JSON_KEY_STATE", "stringifyContext", "caller", "state", "salt", "data", "parseContext", "jsonData", "jsonCaller", "jsonSalt", "generateRandomState", "toBase64URL", "initContext", "caller", "Ed25519KeyIdentity", "nonce", "salt", "generateNonce", "state", "generateRandomState", "storedData", "stringifyContext", "CONTEXT_KEY", "loadContext", "storedContext", "isNullish", "ContextUndefinedError", "parseContext", "fromNullable", "Delegation", "ECDSAKeyIdentity", "getConsoleActor", "getSatelliteActor", "getAuthActor", "auth", "identity", "authenticate", "actorParams", "args", "getAuthActor", "getDelegation", "get_delegation", "DelegationChain", "DelegationIdentity", "generateIdentity", "delegations", "sessionKey", "userKey", "signedDelegations", "delegationChain", "authenticateSession", "jwt", "context", "auth", "sessionKey", "ECDSAKeyIdentity", "publicKey", "delegations", "data", "authenticate", "generateIdentity", "caller", "salt", "result", "AuthenticationError", "userKey", "expiration", "rest", "signedDelegation", "retryGetDelegation", "delegation", "signature", "pubkey", "signedExpiration", "targets", "Delegation", "fromNullable", "maxRetries", "i", "resolve", "getDelegation", "Err", "GetDelegationError", "GetDelegationRetryError", "authenticate", "params", "context", "loadContext", "jwt", "auth", "authenticateSession", "authenticateWithRedirect", "hash", "isEmptyString", "AuthenticationUrlHashError", "state", "idToken", "savedState", "AuthenticationInvalidStateError", "AuthenticationUndefinedJwtError", "isNullish", "notEmptyString", "requestJwtWithRedirect", "authUrl", "clientId", "nonce", "loginHint", "authScopes", "state", "redirectUrl", "requestUrl", "InvalidUrlError", "currentUrl", "notEmptyString", "requestWithCredentials", "configURL", "domainHint", "identityCredential", "isNullish", "FedCMIdentityCredentialUndefinedError", "type", "FedCMIdentityCredentialInvalidError", "jwt", "requestJwt", "google", "context", "initContext", "credentials", "configUrl", "GOOGLE_PROVIDER", "requestWithCredentials", "redirect", "authUrl", "authScopes", "requestJwtWithRedirect", "isFedCMSupported", "userAgent"]
}
