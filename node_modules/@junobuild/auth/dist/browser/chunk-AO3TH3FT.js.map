{
  "version": 3,
  "sources": ["../../src/_openid.ts"],
  "sourcesContent": ["import {isNullish, notEmptyString} from '@dfinity/utils';\nimport {\n  FedCMIdentityCredentialInvalidError,\n  FedCMIdentityCredentialUndefinedError,\n  InvalidUrlError\n} from './errors';\nimport type {RequestJwtWithCredentials, RequestJwtWithRedirect} from './types/openid';\n\n/**\n * Initiates an OpenID Connect authorization request by redirecting the browser.\n *\n *  References:\n *  - OAuth 2.0 (Google): https://developers.google.com/identity/protocols/oauth2/javascript-implicit-flow\n *  - OpenID Connect: https://developers.google.com/identity/openid-connect/openid-connect\n */\nexport const requestJwtWithRedirect = ({\n  authUrl,\n  clientId,\n  nonce,\n  loginHint,\n  authScopes,\n  state,\n  redirectUrl\n}: RequestJwtWithRedirect) => {\n  const parseAuthUrl = (): URL => {\n    try {\n      // Use the URL constructor, for backwards compatibility with older Android/WebView.\n      return new URL(authUrl);\n    } catch (_error: unknown) {\n      throw new InvalidUrlError('Cannot parse authURL', {cause: authUrl});\n    }\n  };\n\n  const requestUrl = parseAuthUrl();\n\n  requestUrl.searchParams.set('client_id', clientId);\n\n  const {\n    location: {origin: currentUrl}\n  } = window;\n\n  requestUrl.searchParams.set('redirect_uri', redirectUrl ?? currentUrl);\n\n  // We do not request \"token\" because we use the ID token (JWT).\n  // \"code\" is required according to II's codebase as Apple ID throws an error otherwise.\n  requestUrl.searchParams.set('response_type', 'code id_token');\n\n  requestUrl.searchParams.set('scope', authScopes.join(' '));\n\n  // Used for security reasons. When the provider redirects to the application,\n  // the state will be compared with the session storage value.\n  requestUrl.searchParams.set('state', state);\n\n  // Used to validate the JSON Web Token (JWT) in the backend \u2014 i.e. we pass the nonce\n  // to the provider and make the request to the backend with its salt.\n  requestUrl.searchParams.set('nonce', nonce);\n\n  if (notEmptyString(loginHint)) {\n    requestUrl.searchParams.set('login_hint', loginHint);\n  } else {\n    requestUrl.searchParams.set('prompt', 'select_account');\n  }\n\n  window.location.href = requestUrl.toString();\n};\n\n/**\n * References:\n * - identity spec: https://www.w3.org/TR/fedcm/#browser-api-credential-request-options\n * - https://privacysandbox.google.com/cookies/fedcm/implement/identity-provider\n * - https://privacysandbox.google.com/cookies/fedcm/why\n */\nexport const requestWithCredentials = async ({\n  configUrl: configURL,\n  clientId,\n  nonce,\n  loginHint,\n  domainHint\n}: RequestJwtWithCredentials): Promise<{jwt: string}> => {\n  const identityCredential = await navigator.credentials.get({\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    identity: {\n      context: 'use',\n      providers: [\n        {\n          configURL,\n          clientId,\n          nonce,\n          loginHint,\n          domainHint\n        }\n      ],\n      mode: 'active'\n    },\n    // https://privacysandbox.google.com/cookies/fedcm/implement/relying-party#auto-reauthn\n    mediation: 'required'\n  });\n\n  if (isNullish(identityCredential)) {\n    throw new FedCMIdentityCredentialUndefinedError();\n  }\n\n  const {type} = identityCredential;\n\n  if (\n    type !== 'identity' ||\n    !('token' in identityCredential) ||\n    typeof identityCredential.token !== 'string'\n  ) {\n    // This should be unreachable in FedCM spec-compliant browsers.\n    throw new FedCMIdentityCredentialInvalidError('Invalid credential received from FedCM API', {\n      cause: identityCredential\n    });\n  }\n\n  const {token: jwt} = identityCredential;\n  return {jwt};\n};\n"],
  "mappings": "sDAAA,OAAQ,aAAAA,EAAW,kBAAAC,MAAqB,iBAejC,IAAMC,EAAyB,CAAC,CACrC,QAAAC,EACA,SAAAC,EACA,MAAAC,EACA,UAAAC,EACA,WAAAC,EACA,MAAAC,EACA,YAAAC,CACF,IAA8B,CAU5B,IAAMC,GATe,IAAW,CAC9B,GAAI,CAEF,OAAO,IAAI,IAAIP,CAAO,CACxB,MAA0B,CACxB,MAAM,IAAIQ,EAAgB,uBAAwB,CAAC,MAAOR,CAAO,CAAC,CACpE,CACF,GAEgC,EAEhCO,EAAW,aAAa,IAAI,YAAaN,CAAQ,EAEjD,GAAM,CACJ,SAAU,CAAC,OAAQQ,CAAU,CAC/B,EAAI,OAEJF,EAAW,aAAa,IAAI,eAAgBD,GAAeG,CAAU,EAIrEF,EAAW,aAAa,IAAI,gBAAiB,eAAe,EAE5DA,EAAW,aAAa,IAAI,QAASH,EAAW,KAAK,GAAG,CAAC,EAIzDG,EAAW,aAAa,IAAI,QAASF,CAAK,EAI1CE,EAAW,aAAa,IAAI,QAASL,CAAK,EAEtCQ,EAAeP,CAAS,EAC1BI,EAAW,aAAa,IAAI,aAAcJ,CAAS,EAEnDI,EAAW,aAAa,IAAI,SAAU,gBAAgB,EAGxD,OAAO,SAAS,KAAOA,EAAW,SAAS,CAC7C,EAQaI,EAAyB,MAAO,CAC3C,UAAWC,EACX,SAAAX,EACA,MAAAC,EACA,UAAAC,EACA,WAAAU,CACF,IAAyD,CACvD,IAAMC,EAAqB,MAAM,UAAU,YAAY,IAAI,CAGzD,SAAU,CACR,QAAS,MACT,UAAW,CACT,CACE,UAAAF,EACA,SAAAX,EACA,MAAAC,EACA,UAAAC,EACA,WAAAU,CACF,CACF,EACA,KAAM,QACR,EAEA,UAAW,UACb,CAAC,EAED,GAAIE,EAAUD,CAAkB,EAC9B,MAAM,IAAIE,EAGZ,GAAM,CAAC,KAAAC,CAAI,EAAIH,EAEf,GACEG,IAAS,YACT,EAAE,UAAWH,IACb,OAAOA,EAAmB,OAAU,SAGpC,MAAM,IAAII,EAAoC,6CAA8C,CAC1F,MAAOJ,CACT,CAAC,EAGH,GAAM,CAAC,MAAOK,CAAG,EAAIL,EACrB,MAAO,CAAC,IAAAK,CAAG,CACb",
  "names": ["isNullish", "notEmptyString", "requestJwtWithRedirect", "authUrl", "clientId", "nonce", "loginHint", "authScopes", "state", "redirectUrl", "requestUrl", "InvalidUrlError", "currentUrl", "notEmptyString", "requestWithCredentials", "configURL", "domainHint", "identityCredential", "isNullish", "FedCMIdentityCredentialUndefinedError", "type", "FedCMIdentityCredentialInvalidError", "jwt"]
}
