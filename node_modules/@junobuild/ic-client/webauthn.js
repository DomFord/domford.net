import{uint8ArrayToArrayOfNumber as H}from"@dfinity/utils";var I=({authData:e})=>{if(e.byteLength<37)return{invalidAuthData:null};if(e.byteLength<53)return{invalidAuthData:null};let t=e.slice(37,53),n=K({bytes:t});return"aaguid"in n?{aaguidBytes:t,aaguidText:n.aaguid}:{unknownProvider:null}},K=({bytes:e})=>{if(e.length!==16)return{invalidBytes:null};let n=(e instanceof Uint8Array?H(e):e).map(r=>r.toString(16).padStart(2,"0")).join("").replace(/^(.{8})(.{4})(.{4})(.{4})(.{12})$/,"$1-$2-$3-$4-$5");return n==="00000000-0000-0000-0000-000000000000"?{unknownProvider:null}:{aaguid:n}};import{DER_COSE_OID as V,wrapDER as j}from"@icp-sdk/core/agent";function S(e){let t=new DataView(new ArrayBuffer(2)),n=e.slice(53,55);[...new Uint8Array(n)].forEach((a,s)=>t.setUint8(s,a));let r=t.getUint16(0);return e.slice(55+r)}function U(e){return j(e,V)}var y=class{constructor(t){this._cose=t;this.#t=U(t)}#t;toDer(){return this.#t}toRaw(){return new Uint8Array(this.#t)}};import{uint8ArrayToBase64 as $}from"@dfinity/utils";var p=class{#t;#e;constructor({rawId:t,cose:n}){this.#t=t,this.#e=new y(n)}getPublicKey(){return this.#e}getCredentialId(){return this.#t}getCredentialIdText(){return $(this.#t)}},h=class extends p{#t;#e;constructor({authData:t,...n}){super(n);let r=I({authData:t});this.#t="aaguidText"in r?r.aaguidText:void 0,this.#e="aaguidBytes"in r?r.aaguidBytes:void 0}getAAGUID(){return this.#e}getAAGUIDText(){return this.#t}},g=class extends p{};var A=class extends Error{},b=class extends Error{},f=class extends Error{},m=class extends Error{},C=class extends Error{},P=class extends Error{},w=class extends Error{},l=class extends Error{},E=class extends Error{};import{arrayBufferToUint8Array as d,isNullish as u,uint8ArraysEqual as Q}from"@dfinity/utils";import{Cbor as N,SignIdentity as X}from"@icp-sdk/core/agent";var O={ECDSA_WITH_SHA256:-7,RSA_WITH_SHA256:-257},v=6e4;var k=()=>window.crypto.getRandomValues(new Uint8Array(16)),M=()=>k(),Y=()=>k(),J=()=>{let{location:{href:e}}=window;try{let{hostname:t}=new URL(e);return t}catch{throw new A}},D=({appId:e})=>e?.id??J(),R=({appId:e,user:t}={})=>{let{document:{title:n}}=window,r=()=>({rp:{name:e?.name??n,id:D({appId:e})}}),a=()=>({user:{id:Y(),name:t?.name??t?.displayName??n,displayName:t?.displayName??n}});return{attestation:"direct",challenge:M(),...r(),...a(),pubKeyCredParams:Object.values(O).map(s=>({type:"public-key",alg:s})),excludeCredentials:[],authenticatorSelection:{authenticatorAttachment:"platform",userVerification:"preferred",residentKey:"required",requireResidentKey:!0}}},_=(e={})=>({rpId:D(e),allowCredentials:[],userVerification:"required"});var x=async({fn:e,step:t,onProgress:n})=>{n?.({step:t,state:"in_progress"});try{let r=await e();return n?.({step:t,state:"success"}),r}catch(r){throw n?.({step:t,state:"error"}),r}};var B=(r=>(r[r.RequestingUserCredential=0]="RequestingUserCredential",r[r.FinalizingCredential=1]="FinalizingCredential",r[r.Signing=2]="Signing",r))(B||{});var G=({timeout:e})=>AbortSignal.timeout(e??v),Z=async({challenge:e,credentialIds:t,passkeyOptions:n,timeout:r})=>await navigator.credentials.get({publicKey:{..._(n),challenge:e.buffer,allowCredentials:(t??[]).map(a=>({id:a.buffer,type:"public-key"}))},signal:G({timeout:r})}),z=e=>{if(e.status!=="initialized")throw new b},q=e=>{if(u(e))throw new f},L=({type:e})=>{if(e!=="public-key")throw new m},F=class e extends X{#t;#e;constructor({onProgress:t,...n}){if(super(),this.#t=t,"retrievePublicKey"in n){let{retrievePublicKey:r}=n;this.#e={status:"pending",retrievePublicKey:r};return}this.#e=e.#r({credential:new h(n)})}static#r({credential:t}){return{status:"initialized",credential:t}}static async createWithNewCredential({passkeyOptions:t,timeout:n,...r}={}){let a=await navigator.credentials.create({publicKey:R(t),signal:G({timeout:n})});q(a),L(a);let{response:{attestationObject:s},rawId:i}=a;if(u(s))throw new C;let{authData:o}=N.decode(d(s)),c=S(o);return new e({...r,rawId:d(i),cose:c,authData:o})}static async createWithExistingCredential(t){return new e(t)}getPublicKey(){z(this.#e);let{credential:t}=this.#e;return t.getPublicKey()}getCredential(){z(this.#e);let{credential:t}=this.#e;return t}async sign(t){let r=await x({fn:async()=>{let i=await Z({challenge:t,...this.#e.status==="initialized"&&{credentialIds:[this.#e.credential.getCredentialId()]}});return q(i),L(i),i},step:0,onProgress:this.#t});return await x({fn:async()=>{let{rawId:i}=r;if(this.#e.status==="initialized"){if(!Q({a:this.#e.credential.getCredentialId(),b:d(i)}))throw new P;return}let{retrievePublicKey:o}=this.#e,c=await o({credentialId:d(i)});this.#e=e.#r({credential:new g({rawId:d(i),cose:c})})},step:1,onProgress:this.#t}),await x({fn:async()=>{let{response:i}=r,{clientDataJSON:o}=i,{authenticatorData:c,signature:T}="authenticatorData"in i&&"signature"in i?i:{};if(u(c))throw new l;if(u(T))throw new l;let W=N.encode({authenticator_data:c,client_data_json:new TextDecoder().decode(o),signature:d(T)});if(u(W))throw new w;return Object.assign(W,{__signature__:void 0}),W},step:2,onProgress:this.#t})}};import{nonNullish as ee}from"@dfinity/utils";var Ue=async()=>ee(window.PublicKeyCredential)&&"isUserVerifyingPlatformAuthenticatorAvailable"in PublicKeyCredential?await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable():!1;export{y as CosePublicKey,p as WebAuthnCredential,g as WebAuthnExistingCredential,F as WebAuthnIdentity,f as WebAuthnIdentityCreateCredentialOnTheDeviceError,b as WebAuthnIdentityCredentialNotInitializedError,m as WebAuthnIdentityCredentialNotPublicKeyError,w as WebAuthnIdentityEncodeCborSignatureError,A as WebAuthnIdentityHostnameError,P as WebAuthnIdentityInvalidCredentialIdError,C as WebAuthnIdentityNoAttestationError,l as WebAuthnIdentityNoAuthenticatorDataError,E as WebAuthnIdentityNoSignatureError,h as WebAuthnNewCredential,B as WebAuthnSignProgressStep,K as bytesToAAGUID,Ue as isWebAuthnAvailable};
//# sourceMappingURL=webauthn.js.map
