import { type Signature, SignIdentity } from '@icp-sdk/core/agent';
import { type WebAuthnCredential, WebAuthnExistingCredential, WebAuthnNewCredential } from './credential';
import type { CreateWebAuthnIdentityWithExistingCredentialArgs, CreateWebAuthnIdentityWithNewCredentialArgs, PublicKeyWithToRaw } from './types/identity';
/**
 * A signing identity for the Internet Computer, backed by a WebAuthn credential.
 *
 * Use one of the factory methods to construct an instance:
 * - {@link WebAuthnIdentity.createWithNewCredential} to create a new passkey on the device.
 * - {@link WebAuthnIdentity.createWithExistingCredential} to use an existing passkey.
 *
 * @template T Concrete credential type for this identity
 * ({@link WebAuthnNewCredential} or {@link WebAuthnExistingCredential}).
 */
export declare class WebAuthnIdentity<T extends WebAuthnCredential> extends SignIdentity {
    #private;
    /**
     * @hidden Use the factory methods instead.
     *
     * Initializes the identity in either:
     * - **pending** state (existing-credential path; public key not yet known), or
     * - **initialized** state (new-credential path; public key known immediately).
     *
     * @private
     */
    private constructor();
    /**
     * Creates a new passkey on the device and returns an initialized identity.
     *
     * If you chain `create` and `sign`, the user will be prompted twice to authenticate
     * with their authenticator. You can track progress via the `onProgress` callback.
     *
     * @param args {@link CreateWebAuthnIdentityWithNewCredentialArgs} Options to create the passkey.
     * @returns A {@link WebAuthnIdentity} parameterized with {@link WebAuthnNewCredential}.
     */
    static createWithNewCredential({ passkeyOptions, timeout, ...restArgs }?: CreateWebAuthnIdentityWithNewCredentialArgs): Promise<WebAuthnIdentity<WebAuthnNewCredential>>;
    /**
     * Creates an identity for an existing passkey.
     *
     * @param args {@link CreateWebAuthnIdentityWithExistingCredentialArgs} Options to retrieve the passkey.
     * @returns A {@link WebAuthnIdentity} parameterized with {@link WebAuthnExistingCredential}.
     */
    static createWithExistingCredential(args: CreateWebAuthnIdentityWithExistingCredentialArgs): Promise<WebAuthnIdentity<WebAuthnExistingCredential>>;
    /**
     * Returns the credential’s public key.
     *
     * @returns {PublicKey}
     * @throws WebAuthnIdentityCredentialNotInitializedError if the identity has not signed
     * any request yet.
     */
    getPublicKey(): PublicKeyWithToRaw;
    /**
     * Returns the concrete credential wrapper for this identity.
     *
     * For identities created with:
     * - `createWithNewCredential` → {@link WebAuthnNewCredential}
     * - `createWithExistingCredential` → {@link WebAuthnExistingCredential}
     *
     * @throws WebAuthnIdentityCredentialNotInitializedError if the identity has not signed
     * any request yet.
     */
    getCredential(): T;
    /**
     * Signs an arbitrary blob using the platform authenticator.
     *
     * @param blob Bytes to sign (used as the WebAuthn challenge).
     * @returns {Promise<Signature>} CBOR-encoded signature payload.
     */
    sign(blob: Uint8Array): Promise<Signature>;
}
